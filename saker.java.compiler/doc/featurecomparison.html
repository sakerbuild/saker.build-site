<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Feature comparison&nbsp;|&nbsp;saker.java.compiler</title>
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/>
	
	<link rel="stylesheet" href="../../res/bootstrap.min.css" >
	<link rel="stylesheet" href="../../res/doc-saker.css" >
</head>
<body data-nav-location="packagedoc" data-subdoc-presence="nest-package packagedoc javadoc taskdoc">
<div class="doc-nav-bar">
	<div class="container">
		<a class="home-link" href="../index.html" title="saker.java.compiler"><img style="height: 2.5em;" class="logo" src="../../res/logo.svg"/><span class="page-name">saker.java.compiler</span></a>
		<a class="nav-location-item" data-nav-location="doc-docs" href="../doc/index.html" title="Documentation">Documentation</a>
		<a class="nav-location-item" data-nav-location="doc-taskdoc" href="../taskdoc/index.html" title="Build task documentation">TaskDoc</a>
		<a class="nav-location-item" data-nav-location="doc-javadoc" href="../javadoc/index.html"title="Java API documentation">JavaDoc</a>
	</div>
</div>
<div class="container page-contents packagedoc">
	<div class="row">
		<div class="col-12 col-lg-3 col-xl-2 p-lg-0">
			<div class="doc-navigation-container">
				<label class="d-lg-none nav-collapse" for="doc-collapse-nav-label">
					<svg style="height: 1.5em;" viewBox="0 0 24 24">
					    <path fill="currentColor" d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" />
					</svg>
					Navigation
				</label>
				<input style="display:none;" id="doc-collapse-nav-label" type="checkbox"/> 
				<div class="doc-nav">  <div class="doc-section"><ul><li><a class="doc-nav-section-link" href="../index.html" title="Index">Index</a></li></ul>  </div>  <div class="doc-section">    <p class="section-title">Package details</p><ul><li><a class="doc-nav-section-link" href="index.html" title="Overview">Overview</a></li><li><a class="doc-nav-section-link" href="gettingstarted.html" title="Getting started">Getting started</a></li><li class="doc-active doc-active-parent"><a class="doc-nav-section-link" href="featurecomparison.html" title="Feature comparison">Feature comparison</a></li><li><a class="doc-nav-section-link" href="performancecomparison.html" title="Performance comparison">Performance comparison</a></li><li><a class="doc-nav-section-link" href="implementationinsights.html" title="Implementation insights">Implementation insights</a></li></ul>  </div>  <div class="doc-section">    <p class="section-title">Java compilation</p><ul><li><a class="doc-nav-section-link" href="javacompile/index.html" title="Overview">Overview</a></li><li><a class="doc-nav-section-link" href="javacompile/basics.html" title="Basics">Basics</a></li><li><label class="doc-nav-collapse" for="_doc_collapse_id_0"><a class="doc-nav-section-link" href="javacompile/processors.html" title="Annotation processors">Annotation processors</a></label><input style="display:none;" id="_doc_collapse_id_0" type="checkbox"/><label class="doc-nav-section-arrow" for="_doc_collapse_id_0"></label><ul><li><a class="doc-nav-section-link" href="javacompile/processorconfig.html" title="Configuration">Configuration</a></li></ul></li><li><a class="doc-nav-section-link" href="javacompile/crosscompile.html" title="Cross-compilation">Cross-compilation</a></li><li><a class="doc-nav-section-link" href="javacompile/compileroptions.html" title="Compiler options">Compiler options</a></li><li><a class="doc-nav-section-link" href="javacompile/sdkmanagement.html" title="SDK management">SDK management</a></li><li><a class="doc-nav-section-link" href="javacompile/bundleclasspath.html" title="Bundle classpath">Bundle classpath</a></li></ul>  </div>  <div class="doc-section">    <p class="section-title">Examples</p><ul><li><a class="doc-nav-section-link" href="examples/index.html" title="Overview">Overview</a></li><li><a class="doc-nav-section-link" href="examples/simple.html" title="Simple compilation">Simple compilation</a></li><li><a class="doc-nav-section-link" href="examples/sourcefilter.html" title="Filter sources">Filter sources</a></li><li><a class="doc-nav-section-link" href="examples/classpath.html" title="Classpath">Classpath</a></li><li><a class="doc-nav-section-link" href="examples/processing.html" title="Annotation processing">Annotation processing</a></li><li><a class="doc-nav-section-link" href="examples/compilerparameters.html" title="Compiler parameters">Compiler parameters</a></li><li><a class="doc-nav-section-link" href="examples/parameternames.html" title="Reflection parameter names">Reflection parameter names</a></li><li><a class="doc-nav-section-link" href="examples/debuginfo.html" title="Debug information">Debug information</a></li><li><a class="doc-nav-section-link" href="examples/injectmoduleinfo.html" title="Injecting module-info attributes">Injecting module-info attributes</a></li><li><a class="doc-nav-section-link" href="examples/nativeheaders.html" title="Native headers">Native headers</a></li><li><a class="doc-nav-section-link" href="examples/jnicompile.html" title="JNI compilation">JNI compilation</a></li><li><a class="doc-nav-section-link" href="examples/addexports.html" title="Add module exports">Add module exports</a></li><li><a class="doc-nav-section-link" href="examples/crosscompile.html" title="Cross-compilation">Cross-compilation</a></li><li><a class="doc-nav-section-link" href="examples/nestbundleclasspath.html" title="Nest bundle classpath">Nest bundle classpath</a></li></ul>  </div></div>
			</div>
		</div>
		<div class="col-12 col-lg-9 col-xl-10 doc-page">
			<div class="sb-sponsors" style="display: none;">
	<span class="sb-sponsors-title">Sponsors</span>
	<div class="container">
		<div class="row">
			<div class="col-md-4 col-12">
				<a class="sb-sponsors-link"></a>
			</div>
			<div class="col-md-4 col-12">
				<a class="sb-sponsors-link"></a>
			</div>
			<div class="col-md-4 col-12">
				<a class="sb-sponsors-link"></a>
			</div>
		</div>
	</div>
</div>
			<div class="doc-content"><h1 id="feature-comparison">Feature comparison<a class="doc-heading-anchor" href="#feature-comparison"></a></h1>
<p>On the <a href="index.html" title="Overview">overview page</a> we've claimed that the saker.java.compiler package provides the <em>single, correct and only complete solution for incremental Java compilation that is currently available in the software development industry</em>. This document makes an attempt to prove that by comparing the feature sets of existing compilation techniques with saker.java.compiler.</p>
<p>The premise of the comparison that the solutions must support incremental Java compilation in some way. Incremental compilation is the act of reusing previous outputs to produce compilation result, and execute only the minimal amount of work required. Incremental compilation can provide a significant build speed boost when large or multi-module projects are in play.</p>
<p>Based on the above, we've found that the existing solutions for incremental Java compilation are the following:</p>
<ul>
<li>The incremental Java compiler available for the Eclipse IDE. (via <a href="https://www.eclipse.org/jdt/core/" title="JDT Core Component | The Eclipse Foundation">JDT Core Component</a>)</li>
<li>The Gradle <a href="https://docs.gradle.org/current/userguide/java_plugin.html" title="The Java Plugin">Java plugin</a> that supports incremental Java compilation. (Introduced in <a href="https://blog.gradle.org/incremental-compiler-avoidance" title="Incremental Compilation, the Java Library Plugin, and other performance features in Gradle 3.4">Gradle 3.4</a>)</li>
</ul>
<p><em>Disclaimer: If we've missed any existing solutions, or are misinformed with the mentioned technologies in the article, please <a href="/contact.html">contact us</a> so we can correct ourselves.</em></p>
<h2 id="eclipse-java-compiler">Eclipse Java Compiler<a class="doc-heading-anchor" href="#eclipse-java-compiler"></a></h2>
<p>The Java compiler used in the Eclipse IDE is a complete reimplementation of the Java compiler. It doesn't require a JDK, and has no relation to the <code>javac</code> tool. This has both advantages and disadvantages. It induces an enormous maintenance burden on the authors, as they need to keep up with the compiler development as the Java language evolves.</p>
<p>The separate implementation may also contain bugs that otherwise aren't present in the <code>javac</code> implementation. Some examples that we've found during the development of the saker.java.compiler package (and haven't been fixed yet):</p>
<ul>
<li><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=531202" title="531202 &ndash; Java compilation succeeds when functions collide by type variable">Java compilation succeeds when functions collide by type variable</a></li>
<li><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=528859" title="528859 &ndash; Compilation fails for heavily templated functional interface">Compilation fails for heavily templated functional interface</a></li>
<li><a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=528363" title="528363 &ndash; Eclipse compiler resolves typename from superclass instead of template type">Eclipse compiler resolves typename from superclass instead of template type</a></li>
</ul>
<p>These bugs however, doesn't reduce the great impact that it has on the Java ecosystem. The Eclipse Java Compiler can be very well used in the Eclipse IDE as it can compile the modified sources nearly instantaneously.</p>
<p>However, when annotation processors are used, the Eclipse Java Compiler falls short. It doesn't provide any incremental compilation related features for annotation processors, which can result it being tedious or simply unsuitable to use. We consider this a serious shortcoming, as the annotation processors can greatly improve the Java development experience.</p>
<p>One of the most popular annotation processors, <a href="https://github.com/google/dagger" title="GitHub - google/dagger: A fast dependency injector for Android and Java.">google/dagger</a> has 14.5k starts on GitHub, signaling that annotation processors shouldn't be neglected in relation with Java compilation.</p>
<p>The Eclipse Java Compiler works very well in the IDE, however, in cases when it needs to be integrated with build systems, and build processes that aren't directly related to the Eclipse IDE, we haven't found a way to have incremental compilation features. Meaning that as far as we know, the Eclipse provided incremental Java compilation features only available inside an IDE, and not externally invokeable. (Please correct us if we're wrong.)</p>
<h2 id="gradle-java-plugin">Gradle Java plugin<a class="doc-heading-anchor" href="#gradle-java-plugin"></a></h2>
<p>The Gradle build system comes with a Java plugin that supports incremental Java compilation. They implement this by analyzing the bytecode that comes out of <code>javac</code>, and determine the dependencies for the compiled classes. They also support incremental annotation processing which is not a straightforward thing to implement.</p>
<p>We can say that they are pioneers in regards of improving the Java compilation experience for the Java ecosystem, and their efforts are not to be overlooked. However, their solution has major shortcomings, and not because of the flaws in the implementation, but because the Java class file format doesn't provide enough information to properly determine the dependencies based on them.</p>
<p>Some of the problems that arise with their solution in the importance order we see fit:</p>
<p><strong>Constant declarations cause full recompilation.</strong> (<a href="https://github.com/gradle/gradle/issues/6482" title="Make incremental compile faster on constant changes · Issue #6482 · gradle/gradle · GitHub">Related issue</a>) Java constants are field declarations that are <code>public static final</code>, have a primitive or <code>String</code> type, and is initialized with a constant expression. Like the followings:</p>
<pre><code class="language-java">public static final int MAGIC_NUMBER = 123;
public static final String SECRET_PASSWORD = &quot;...&quot;;
public static final int SOME_FLAG_VALUE = 1 &lt;&lt; 12;
</code></pre>
<p>If you modify a Java source file that contains public constants, then Gradle will do a full recompilation of the project. This is unacceptable, and can seriously disrupt workflow for large projects. (See their own <a href="https://github.com/gradle/performance-comparisons/tree/master/single-large-project" title="performance-comparisons/single-large-project at master · gradle/performance-comparisons · GitHub">performance comparison project</a> that contains 50 000 source files. Compilation can even take 50 seconds.)</p>
<p>The official solution for this is to not use constants in your codebase. We believe that the tooling should never impose restrictions on the codebase of your project, and this falls into that scenario.</p>
<p><strong>Dead code elimination can leave sources in an erroneous state.</strong> <code>javac</code> will not include instructions in the resulting class files if it can determine that the given code will never be executed. This dead code elimination can cause the codebase to contain unnoticed errors even after a successful compilation. Let's look at the following code (with some boilerplate context eliminated for compactness):</p>
<pre><code class="language-java">// Foo.java:
public static final boolean SOME_CONDITION = false;

// Baz.java:
if (Foo.SOME_CONDITION) {
	Bar.doSomething();
}

// Bar.java:
public static void doSomething() {
	// ...	
}
</code></pre>
<p>We compile the code, and it succeeds. The call to <code>Bar.doSomething()</code> in <code>Baz</code> will be eliminated by the Java compiler. Everything's fine, however, we later decide to modify <em>only</em> the <code>Bar.doSomething()</code> method signature to include a new parameter:</p>
<pre><code class="language-java">// Bar.java:
public static void doSomething(int value) {
	// ...	
}
</code></pre>
<p>If we recompile our project, it succeeds, although <strong>it should not</strong>. It should fail, as the <code>Bar.doSomething()</code> in <code>Baz</code> is now invalid. However, due to the fact that the class file of <code>Baz</code> doesn't contain a reference to <code>Bar.doSomething()</code>, <code>Baz</code> will <strong>not</strong> be recompiled.</p>
<p>So we've succeeded with the compilation, the tests, and we push our code to the source repository. The first place where we're noticed about the error is the CI server that we've hopefully set up for our project. We believe that this is an unacceptable scenario. You might think that this is an insignificant edge-case, however, there are many use-cases like testing and build flags, flavors, where issues like this can often emerge.</p>
<p><strong>Template parameter modification may result in incorrect code.</strong> If a type is only present as a template arugment for a type, Gradle may not recompile the affected class in case of class hieararchy modifications. If we start out with the following sources:</p>
<pre><code class="language-java">// Foo.java:
public class Foo { ... }

// Baz.java:
// (local variable)
ArrayList&lt;Foo&gt; list = new ArrayList&lt;&gt;();
</code></pre>
<p>The compilation will succeed. If we the decide to completely delete the <code>Foo</code> class, Gradle may not recompile <code>Baz.java</code>, therefore leaving it in an erroneous state. This is a minor edge-case that we believe rarely happens, but still shows limitations of the class file based dependency discovery.</p>
<p>There are other smaller edge cases that may leave the codebase in an erroneous state, or straight up produce incorrect code, however, they are so rarely occurring that we won't bore the reader with it. Most of them are related to wildcard imports, <a href="https://github.com/gradle/gradle/issues/8590" title="Adding a top-level class in the package may break incremental compilation · Issue #8590 · gradle/gradle · GitHub">package level class additions</a>, or specific naming edge cases that are all limitations of the class file format. Instead let's focus on how saker.java.compiler improves this.</p>
<h2 id="saker_java_compiler">Saker.java.compiler<a class="doc-heading-anchor" href="#saker_java_compiler"></a></h2>
<p>Our goal when implementing the <a href="../taskdoc/saker.java.compile.html"><code>saker.java.compile()</code></a> task was to improve the incremental Java compilation performance as much as we can while providing correct outputs. We've implemented a solution purely based on the <a href="https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/index.html" title="Compiler Tree API">Java Compiler API</a> that supports correct dependency discovery of every compiled class and allows us to implement incremental annotation processing.</p>
<p>In our implementation we run the annotation processing ourselves, which has the disadvantage of having to reimplement the mechanism provided by <code>javac</code>, however, the advantage of supporting source retention annotations and parallel annotation processing greatly outshine that drawback.</p>
<p>Our implementation still has some missing features, but that is only because the lack of time spent implementing them, and not due to other technical limitations. One such restriction is that class file generation is not yet supported for annotation processors. Some rarely used features are also not yet available using the <a href="../taskdoc/saker.java.compile.html"><code>saker.java.compile()</code></a> task.</p>
<p>In the <a href="performancecomparison.html" title="Performance comparison">performance measuresments</a> we also prove that our implementation is the best solution for fast Java compilation.</p>
<h2 id="conclusion">Conclusion<a class="doc-heading-anchor" href="#conclusion"></a></h2>
<p>We've seen that existing solutions for correct and fast incremental Java compilation have lacking support for core features of Java development. With the <a href="../taskdoc/saker.java.compile.html"><code>saker.java.compile()</code></a> task we present an alternative that compiles Java sources in a correct and scalable way, both for large and complex projects.</p>
<link href="../../css/sakerscript.css"  rel="stylesheet" type="text/css" /></div>
			<div class="end-section-links">
				<div class="end-section-prev">
					<a class="doc-prev-section" href="../doc/gettingstarted.html" title="Getting started"><svg class="doc-section-arrow" viewBox="0 0 24 24">
    <path fill="currentColor" d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" />
</svg>Getting started</a>
				</div>
				<div class="end-section-next">
					<a class="doc-next-section" href="../doc/performancecomparison.html" title="Performance comparison">Performance comparison<svg class="doc-section-arrow" viewBox="0 0 24 24">
    <path fill="currentColor" d="M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z" />
</svg></a>
				</div>
			</div>
			<div class="doc-headings-nav">  <ul>    <li><a href="#feature-comparison" title="Feature comparison">Feature comparison</a>      <ul>        <li><a href="#eclipse-java-compiler" title="Eclipse Java Compiler">Eclipse Java Compiler</a>        </li>        <li><a href="#gradle-java-plugin" title="Gradle Java plugin">Gradle Java plugin</a>        </li>        <li><a href="#saker_java_compiler" title="Saker.java.compiler">Saker.java.compiler</a>        </li>        <li><a href="#conclusion" title="Conclusion">Conclusion</a>        </li>      </ul>    </li>  </ul></div>
		</div>
	</div>
</div>
<div class="doc-footer">
	<div class="container">
		<div class="row">
			<div class="footer-section col-6 col-sm-4 col-md-3">
				<p class="footer-section-title">About</p>
				<div><a href="/index.html" title="Saker.build home page">Home</a></div>
				<div data-footer-location="doc-docs"><a href="../index.html" title="saker.java.compiler documentation index">Documentation index</a></div>
				<div><a href="../../saker.build/index.html" title="Information about the saker.build system">saker.build system</a></div>
				<div><a href="../../saker.nest/index.html" title="Information about the saker.nest repository">saker.nest repository</a></div>
				<div><a href="/contact.html" title="Contact us">Contact</a></div>
			</div>
			<div class="footer-section col-6 col-sm-4 col-md-3">
				<p class="footer-section-title">Resources</p>
				<div data-footer-location="doc-docs"><a href="../doc/index.html" title="saker.java.compiler documentation index">Documentation</a></div>
				<div data-footer-location="doc-javadoc"><a href="../javadoc/index.html" title="JavaDoc for saker.java.compiler">JavaDoc</a></div>
				<div data-footer-location="doc-taskdoc"><a href="../taskdoc/index.html"  title="Documentation of build tasks in saker.java.compiler">TaskDoc</a></div>
				<div data-footer-location="nest-package"><a href="https://nest.saker.build/package/saker.java.compiler" title="saker.java.compiler | saker.nest">saker.nest package page</a></div>
				<div><a href="https://github.com/sakerbuild/saker.java.compiler" title="saker.java.compiler on GitHub">GitHub</a></div>
			</div>
		</div>	
		<div class="row">
			<div class="col">
			&copy; Bence Sipka 2020
			</div>
		</div>
	</div>
</div>

<link rel="stylesheet" href="../../res/hljs.css"><script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js" integrity="sha256-js+I1fdbke/DJrW2qXQlrw7VUEqmdeFeOW37UC0bEiU=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.13.1/build/languages/java.min.js"></script>
<script>
if(window.hasOwnProperty("hljs")){
	hljs.configure({
	  languages: []
	});
	hljs.initHighlightingOnLoad();
}
</script>

</body>
</html>